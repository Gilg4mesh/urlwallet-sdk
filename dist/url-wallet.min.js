var UrlWallet=function(e){var n={};function s(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,s),o.l=!0,o.exports}return s.m=e,s.c=n,s.d=function(e,n,t){s.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,n){if(1&n&&(e=s(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)s.d(t,o,function(n){return e[n]}.bind(null,o));return t},s.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(n,"a",n),n},s.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},s.p="",s(s.s=0)}([function(e,n,s){"use strict";s.r(n);var t=class{constructor(e,n,s){this.provider=e,this.port=n,this.methodMap=new Map([["send",this.send],["currentAddress",this.getCurrentAddress]]),this.sendRoutingMap=new Map([]),this.queue=new Map,this.onqueuechange=null,this.currentAddress=null,this._incomingHandler=this._handleRpc.bind(this),this._outgoingHandler=this._handleNotif.bind(this),this.provider.sendAsync?(console.warn('The provider is probably not EIP-1193 compliant. Will send with legacy, callback-based method "sendAsync".'),this.sendAsync=this._sendAsyncLegacy):this.sendAsync=this._sendAsync}bindSubscriptionEvents(e){let n=null;return e?n=e:(n=this.provider,"CustomProvider"==this.provider.host&&(n=this.provider.connection)),!(!n||!n.on)&&(n.on("data",(e,n)=>{if(e)throw e;return this._outgoingHandler(n)}),!0)}_queueChange(e,n){if(this.onqueuechange)if(n)this.onqueuechange(e,null,this.queue);else{const n=this.queue.get(e);this.onqueuechange(e,n,this.queue)}}_handleRpc(e){const{method:n}=e.data;if(null==n)return void console.error("No method provided");const s=this.methodMap.get(n);if(null==s)return void console.error(`No such method "${n}".`);let t=n;"send"==n&&(t+=` "${e.data.payload.method}"`);const o=Symbol(t);this.queue.set(o,"pending"),this._queueChange(o,!1);const{nonce:r,payload:i}=e.data;return s.bind(this)(i).then(e=>{this.port.postMessage({nonce:r,response:e}),this.queue.set(o,"resolved"),this._queueChange(o,!1)}).catch(e=>{this.port.postMessage({nonce:r,error:e}),this.queue.set(o,"rejected"),this._queueChange(o,!1)})}_handleNotif(e){this.port.postMessage({notification:e})}send(e){return"string"==typeof e?Promise.reject(new Error("Invalid JSON-RPC request. send() only allows an object as its payload.")):(console.log('MyRPC forwarding "send":',e),this.sendRoutingMap.has(e.method)?this.sendRoutingMap.get(e.method)(e):this.sendAsync(e))}_sendAsyncLegacy(e){return new Promise((n,s)=>{this.provider.sendAsync(e,(e,t)=>{null!=e?s(e):n(t.result)})})}_sendAsync(e){return this.provider.sendPayload?(e.jsonrpc="2.0",e.id=1,this.provider.sendPayload(e).then(e=>{if(e.error)throw e.error;return e.result})):this.provider.send(e.method,e.param)}getCurrentAddress(){return"selectedAddress"in this.provider?Promise.resolve([this.provider.selectedAddress]):Promise.resolve([this.currentAddress])}};n.default=class{constructor(){this.handshaked=null,this.bridge=null,this.respondToHandshake=this._respondToHandshake.bind(this),this.postMessageHandler=this._postMessageHandler.bind(this),this.openWindow=this._openWindow.bind(this),this.openWindowFromDapp=this._openWindowFromDapp.bind(this),this.openWindowFromIframe=this._openWindowFromIframe.bind(this)}_openWindow(e){const n=window.open(e);return!(!n||n.closed||void 0===n.closed)||(this.bridge.port.postMessage({url:location.origin+"/"+e}),!1)}_openWindowFromDapp(e){this.bridge.port.postMessage({url:location.origin+"/"+e})}_openWindowFromIframe(e){const n=window.open(e);return!(!n||n.closed||void 0===n.closed)||(this.bridge.port.postMessage({windowBlocked:!0}),!1)}_respondToHandshake(e,n){null==n?(e.onmessage=this.bridge._incomingHandler,e.postMessage({ok:!0,msg:"handshake ACK"})):(e.onmessage=()=>{},e.postMessage({ok:!1,msg:"handshake failed",error:n}))}_postMessageHandler(e){if(e.origin)if(location.origin!=e.origin)if(console.log("iframe onmessage",e.data,"from",e.origin,e),"handshake"==e.data.method){if(this.handshaked)return void console.warn("Repeated handshake to iframe! Ignoring...");this.handshaked=!0,this.bridge=new t(web3.currentProvider,e.ports[0]),this.respondToHandshake(e.ports[0],null),window.postMessage({method:"handshakeDone"},location.origin)}else console.error(e);else console.debug("Ignoring self-calling message")}}}]).default;