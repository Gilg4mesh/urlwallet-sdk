!function(e){var n={};function t(s){if(n[s])return n[s].exports;var r=n[s]={i:s,l:!1,exports:{}};return e[s].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=e,t.c=n,t.d=function(e,n,s){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:s})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(t.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(s,r,function(n){return e[n]}.bind(null,r));return s},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(e,n,t){"use strict";t.r(n);var s=class{constructor(e,n,t){this.provider=e,this.port=n,this.methodMap=new Map([["send",this.send],["currentAddress",this.getCurrentAddress]]),this.sendRoutingMap=new Map([]),this.queue=new Map,this.onqueuechange=null,this.currentAddress=null,this._incomingHandler=this._handleRpc.bind(this),this._outgoingHandler=this._handleNotif.bind(this),this.provider.sendAsync?(console.warn('The provider is probably not EIP-1193 compliant. Will send with legacy, callback-based method "sendAsync".'),this.sendAsync=this._sendAsyncLegacy):this.sendAsync=this._sendAsync}bindSubscriptionEvents(e){let n=null;return e?n=e:(n=this.provider,"CustomProvider"==this.provider.host&&(n=this.provider.connection)),!(!n||!n.on||(n.on("data",(e,n)=>{if(e)throw e;return this._outgoingHandler(n)}),0))}_queueChange(e,n){if(this.onqueuechange)if(n)this.onqueuechange(e,null,this.queue);else{const n=this.queue.get(e);this.onqueuechange(e,n,this.queue)}}_handleRpc(e){const{method:n}=e.data;if(null==n)return void console.error("No method provided");const t=this.methodMap.get(n);if(null==t)return void console.error(`No such method "${n}".`);let s=n;"send"==n&&(s+=` "${e.data.payload.method}"`);const r=Symbol(s);this.queue.set(r,"pending"),this._queueChange(r,!1);const{nonce:o,payload:i}=e.data;return t.bind(this)(i).then(e=>{this.port.postMessage({nonce:o,response:e}),this.queue.set(r,"resolved"),this._queueChange(r,!1)}).catch(e=>{this.port.postMessage({nonce:o,error:e}),this.queue.set(r,"rejected"),this._queueChange(r,!1)})}_handleNotif(e){this.port.postMessage({notification:e})}send(e){return"string"==typeof e?Promise.reject(new Error("Invalid JSON-RPC request. send() only allows an object as its payload.")):(console.log('MyRPC forwarding "send":',e),this.sendRoutingMap.has(e.method)?this.sendRoutingMap.get(e.method)(e):this.sendAsync(e))}_sendAsyncLegacy(e){return new Promise((n,t)=>{this.provider.sendAsync(e,(e,s)=>{null!=e?t(e):n(s.result)})})}_sendAsync(e){return this.provider.sendPayload?(e.jsonrpc="2.0",e.id=1,this.provider.sendPayload(e).then(e=>{if(e.error)throw e.error;return e.result})):this.provider.send(e.method,e.param)}getCurrentAddress(){return"selectedAddress"in this.provider?Promise.resolve([this.provider.selectedAddress]):Promise.resolve([this.currentAddress])}};let r=null;window.addEventListener("message",function(e){if(e.origin)if(location.origin!=e.origin)if(console.log("iframe onmessage",e.data,"from",e.origin,e),"handshake"==e.data.action){if(r)return void console.warn("Repeated handshake to iframe! Ignoring...");r=!0;const n=new s(web3.currentProvider,e.ports[0]);!function(e,n,t){null==n?(e.onmessage=t._incomingHandler,e.postMessage({ok:!0,msg:"handshake ACK"})):(e.onmessage=()=>{},e.postMessage({ok:!1,msg:"handshake failed",error:n}))}(e.ports[0],null,n),main&&main(n)}else console.error(e);else console.debug("Ignoring self-calling message")})}]);